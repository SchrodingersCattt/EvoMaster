"""MatMasterAgent: finish only when task_completed=true.

System prompt is always generated by build_mat_master_system_prompt() (tool list + today's date).
"""

from __future__ import annotations

import json
from datetime import datetime, timezone
from pathlib import Path
from typing import Any

from evomaster.agent.agent import Agent
from evomaster.utils.types import AssistantMessage, StepRecord, ToolMessage


class MatMasterAgent(Agent):
    """Agent that only ends the run when the finish tool is called with task_completed=true.

    If the agent calls finish with task_completed=false or partial, we add the
    tool response and continue (do not set should_finish).
    """

    def _get_system_prompt(self) -> str:
        """Use generated system prompt (tool list + date), then append working directory, tool rules, and skills."""
        from ..prompts.build_prompt import build_mat_master_system_prompt

        current_date = datetime.now(timezone.utc).strftime("%Y-%m-%d")
        base = build_mat_master_system_prompt(current_date=current_date)

        working_dir = self.session.config.workspace_path
        working_dir_abs = str(Path(working_dir).absolute())
        working_dir_info = f"\n\nYou must perform all operations in this working directory; do not change directory. All file operations and commands must be run under: {working_dir_abs}"
        prompt = base + working_dir_info

        # Inject tool rules (fix once, apply every run) so repeated tool errors are avoided
        _tool_rules_path = Path(__file__).resolve().parent.parent / "prompts" / "tool_rules.txt"
        if _tool_rules_path.exists():
            prompt += "\n\n" + _tool_rules_path.read_text(encoding="utf-8").strip()

        # Mandatory citation and output format for survey/manuscript — agent MUST follow this
        _citation_format_path = Path(__file__).resolve().parent.parent / "skills" / "_common" / "reference" / "citation_and_output_format.md"
        if _citation_format_path.exists():
            prompt += "\n\n# Citation and output format (mandatory for literature surveys and manuscripts)\n\n"
            prompt += _citation_format_path.read_text(encoding="utf-8").strip()
            prompt += "\n\nYou MUST follow the above format when writing survey reports or manuscript sections: use [n](url) for every citation, include a References section with URL for each [n], and obey General / Citation / References section / Terminology rules."

        if self.skill_registry is not None:
            skills_info = self.skill_registry.get_meta_info_context()
            if skills_info:
                prompt += f"\n{skills_info}\n"
                prompt += """
You can use the 'use_skill' tool to:
1. Get detailed information about a skill: action='get_info'
2. Get reference documentation: action='get_reference'
3. Run scripts from Operator skills: action='run_script'
"""
        return prompt

    def _on_assistant_message(self, msg: AssistantMessage) -> None:
        """Optional hook after assistant message is added. Override in subclasses (e.g. streaming)."""
        pass

    def _on_tool_message(self, msg: ToolMessage) -> None:
        """Optional hook after each tool message is added. Override in subclasses (e.g. streaming)."""
        pass

    def _step(self) -> bool:
        """Override: for finish tool, execute it and only set should_finish when task_completed==true."""
        self._step_count += 1

        dialog_for_query = self.context_manager.prepare_for_query(self.current_dialog)
        assistant_message = self.llm.query(dialog_for_query)
        self.current_dialog.add_message(assistant_message)
        self._on_assistant_message(assistant_message)
        step_record = StepRecord(
            step_id=self._step_count,
            assistant_message=assistant_message,
        )

        if not assistant_message.tool_calls:
            if hasattr(self, "enable_tools") and not self.enable_tools:
                self.trajectory.add_step(step_record)
                self._append_trajectory_entry(dialog_for_query, step_record)
                return True
            self._handle_no_tool_call()
            self.trajectory.add_step(step_record)
            self._append_trajectory_entry(dialog_for_query, step_record)
            return False

        should_finish = False
        for tool_call in assistant_message.tool_calls:
            self.logger.debug("Processing tool call: %s", tool_call.function.name)

            if tool_call.function.name == "finish":
                try:
                    finish_args = json.loads(tool_call.function.arguments)
                    self.logger.info("=" * 80)
                    self.logger.info("Finish Tool Arguments: task_completed=%s", finish_args.get("task_completed"))
                    self.logger.info("=" * 80)
                except Exception:
                    pass

            observation, info = self._execute_tool(tool_call)

            # Remind agent to do multiple retrievals for survey: append after mat_sn paper search
            if tool_call.function.name == "mat_sn_search-papers-enhanced" and info.get("error") is None:
                n_papers = ""
                try:
                    obj = json.loads(observation)
                    if isinstance(obj, dict) and "data" in obj and isinstance(obj["data"], list):
                        n_papers = str(len(obj["data"]))
                except (json.JSONDecodeError, TypeError):
                    pass
                call_count = info.get("call_count", "?")
                reminder = (
                    f"\n\n[Survey reminder: 本次返回 {n_papers or '?'} 篇（第 {call_count} 次检索）。"
                    "综述/调研需至少 6–15 次检索；若结果偏少或检索次数不足，请换 question/words 继续调用 mat_sn_search-papers-enhanced 或 mat_sn_web-search。]"
                )
                observation = observation + reminder

            MAX_TOOL_OUTPUT = 30000
            if len(observation) > MAX_TOOL_OUTPUT:
                observation = (
                    observation[: MAX_TOOL_OUTPUT // 2]
                    + "\n\n... [output truncated due to length] ...\n\n"
                    + observation[-MAX_TOOL_OUTPUT // 2 :]
                )

            if tool_call.function.name == "finish":
                task_completed = info.get("task_completed", "false")
                if task_completed == "true":
                    should_finish = True

            tool_message = ToolMessage(
                content=observation,
                tool_call_id=tool_call.id,
                name=tool_call.function.name,
                meta={"info": info},
            )
            self.current_dialog.add_message(tool_message)
            self._on_tool_message(tool_message)
            step_record.tool_responses.append(tool_message)

        self.trajectory.add_step(step_record)
        self._append_trajectory_entry(dialog_for_query, step_record)
        return should_finish
