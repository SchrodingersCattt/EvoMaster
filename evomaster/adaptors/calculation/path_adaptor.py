"""Path adaptor: Bohrium HTTPS storage and executor/sync logic for calculation MCP tools.

All calculation-related MCP tools must receive OSS (or HTTP) links for path arguments.
If the caller passes a local path, the adaptor uploads the file to OSS and passes
the resulting URL.

Path detection is schema-driven: we inspect the MCP tool's ``input_schema``
(JSON Schema generated by Pydantic) and look for ``"format": "path"`` or
``"format": "file-path"`` on each property.  Parameters typed as ``pathlib.Path``
or ``pydantic.FilePath`` in the MCP server will carry this format tag automatically;
plain ``str`` parameters (like ``model_path``, ``plot_path``) will NOT, so they are
left untouched.  **No parameter names are hard-coded.**
"""

import logging
from pathlib import Path
from typing import Any, Dict, Optional, Set
from urllib.parse import urlparse

from evomaster.env import get_bohrium_storage_config, inject_bohrium_executor

from .oss_io import upload_file_to_oss

logger = logging.getLogger(__name__)

# ---------------------------------------------------------------------------
# JSON Schema ``format`` values that indicate a filesystem path.
# Pydantic v2 emits:
#   pathlib.Path          → "format": "path"
#   pydantic.FilePath     → "format": "file-path"
#   pydantic.DirectoryPath→ "format": "directory-path"
# ---------------------------------------------------------------------------
_PATH_FORMATS: frozenset[str] = frozenset({
    'path',
    'file-path',
    'directory-path',
})


def _has_path_format(prop_schema: dict) -> bool:
    """Return *True* if a single JSON-Schema property describes a Path type.

    Handles:
    * Direct: ``{"type": "string", "format": "path"}``
    * Optional / Union: ``{"anyOf": [{"type": "string", "format": "path"}, {"type": "null"}]}``
    * ``oneOf`` variant of the above.
    """
    fmt = prop_schema.get('format', '')
    if fmt in _PATH_FORMATS:
        return True
    # anyOf / oneOf (used for Optional[Path], Union[Path, ...])
    for branch_key in ('anyOf', 'oneOf'):
        branches = prop_schema.get(branch_key)
        if branches and isinstance(branches, list):
            for branch in branches:
                if isinstance(branch, dict) and branch.get('format', '') in _PATH_FORMATS:
                    return True
    return False


def _path_keys_from_schema(input_schema: Optional[Dict[str, Any]]) -> Set[str]:
    """Derive the set of parameter names whose type is ``Path`` from a JSON Schema.

    Supports:
    * Scalar path: ``"format": "path"``
    * List of paths: ``"type": "array", "items": {"format": "path"}``
    * Optional / Union wrappers (``anyOf`` / ``oneOf``).

    Returns an empty set when *input_schema* is ``None`` or has no path-typed properties.
    """
    if not input_schema or not isinstance(input_schema, dict):
        return set()

    props = input_schema.get('properties') or {}
    out: Set[str] = set()

    for key, spec in props.items():
        if not isinstance(spec, dict):
            continue

        # 1. Direct path property
        if _has_path_format(spec):
            out.add(key)
            continue

        # 2. Array of paths: {"type": "array", "items": {"format": "path"}}
        items = spec.get('items')
        if isinstance(items, dict) and _has_path_format(items):
            out.add(key)
            continue

        # 3. anyOf / oneOf may wrap an array-of-paths
        for branch_key in ('anyOf', 'oneOf'):
            branches = spec.get(branch_key)
            if branches and isinstance(branches, list):
                for branch in branches:
                    if not isinstance(branch, dict):
                        continue
                    if _has_path_format(branch):
                        out.add(key)
                        break
                    b_items = branch.get('items')
                    if isinstance(b_items, dict) and _has_path_format(b_items):
                        out.add(key)
                        break

    return out


def _is_local_path(value: Any) -> bool:
    if not value or not isinstance(value, str):
        return False
    value = value.strip()
    if not value:
        return False
    parsed = urlparse(value)
    if parsed.scheme in ('http', 'https'):
        return False
    if value.lower().startswith('local://'):
        return False
    return True


def _workspace_path_to_local(value: str, workspace_root: Path) -> Path:
    """Map /workspace/... or relative path to actual local Path under workspace_root."""
    value = value.strip().replace('\\', '/')
    if value.startswith('/workspace/'):
        rel = value[len('/workspace/') :].lstrip('/')
        return (workspace_root / rel).resolve()
    if value.startswith('/workspace'):
        rel = value[len('/workspace') :].lstrip('/')
        return (workspace_root / (rel or '.')).resolve()
    path = Path(value)
    if not path.is_absolute():
        return (workspace_root / path).resolve()
    return path


def _resolve_one(value: str, workspace_root: Path) -> str:
    """If value is a local path, upload to OSS and return the OSS URL. Path args must be OSS links for remote MCP."""
    if not _is_local_path(value):
        return value
    path = _workspace_path_to_local(value, workspace_root)
    if not path.exists():
        raise FileNotFoundError(
            f"Path argument file not found: {path}. For calculation MCP tools, input files must exist in workspace so they can be uploaded to OSS and passed as URL."
        )
    if not path.is_file():
        raise ValueError(
            f"Path argument is not a file: {path}. Only files can be uploaded to OSS."
        )
    try:
        return upload_file_to_oss(path, workspace_root)
    except Exception as e:
        raise RuntimeError(
            f"Cannot pass local file to calculation MCP: OSS upload required but failed for {path}. "
            'Set OSS_ENDPOINT, OSS_BUCKET_NAME, OSS_ACCESS_KEY_ID, OSS_ACCESS_KEY_SECRET in .env at project root (run.py loads it).'
        ) from e


class CalculationPathAdaptor:
    """Bohrium storage + per-server executor/sync_tools. Sync tools → executor None; else Bohrium executor with env auth."""

    def __init__(self, calculation_executors: Optional[Dict[str, Any]] = None):
        """Optional config: { server_name: { executor: {...}|null, sync_tools: [str] } }. From mcp.calculation_executors."""
        self.calculation_executors = calculation_executors or {}

    def _resolve_executor(
        self,
        server_name: str,
        remote_tool_name: str,
        access_key: str | None = None,
        project_id: int | str | None = None,
        user_id: int | str | None = None,
    ) -> Optional[Dict[str, Any]]:
        """Return executor for this (server, tool): None if sync tool or no config; else injected Bohrium executor.

        Args:
            server_name: MCP 服务器名称
            remote_tool_name: 远程工具名称
            access_key: 可选的 access_key，如果提供则优先使用
            project_id: 可选的 project_id，如果提供则优先使用
            user_id: 可选的 user_id，如果提供则优先使用
        """

        server_cfg = self.calculation_executors.get(server_name)
        if not server_cfg:
            return None
        sync_tools = server_cfg.get('sync_tools') or []
        if remote_tool_name in sync_tools:
            return None
        # Per-tool executor_map: allows different images/machine types for each tool under the same server
        executor_map = server_cfg.get("executor_map")
        if executor_map and isinstance(executor_map, dict):
            tool_executor = executor_map.get(remote_tool_name)
            if tool_executor and isinstance(tool_executor, dict):
                return inject_bohrium_executor(
                    tool_executor,
                    access_key=access_key,
                    project_id=project_id,
                    user_id=user_id,
                )
        # Fallback to server-level default executor
        executor_template = server_cfg.get('executor')
        if not executor_template or not isinstance(executor_template, dict):
            return None
        return inject_bohrium_executor(
            executor_template,
            access_key=access_key,
            project_id=project_id,
            user_id=user_id,
        )

    def resolve_args(
        self,
        workspace_path: str,
        args: Dict[str, Any],
        tool_name: str,
        server_name: str,
        input_schema: Optional[Dict[str, Any]] = None,
        access_key: str | None = None,
        project_id: int | str | None = None,
        user_id: int | str | None = None,
    ) -> Dict[str, Any]:
        """Inject executor, storage and resolve Path-typed args → OSS URL.

        Path detection is **schema-driven**: only parameters whose JSON Schema
        carries ``"format": "path"`` (or ``"file-path"`` / ``"directory-path"``)
        are treated as file paths.  Plain ``str`` parameters are never touched.

        Args:
            workspace_path: 工作区路径
            args: 工具参数
            tool_name: 工具名称 (prefixed)
            server_name: MCP 服务器名称
            input_schema: MCP tool JSON Schema (from ``tool.inputSchema``)
            access_key: 可选的 access_key，如果提供则优先使用
            project_id: 可选的 project_id，如果提供则优先使用
            user_id: 可选的 user_id，如果提供则优先使用
        """
        out = dict(args)
        remote_name = tool_name
        if server_name and tool_name.startswith(server_name + '_'):
            remote_name = tool_name[len(server_name) + 1 :]

        # --- executor & storage injection (unchanged) ---
        out['executor'] = self._resolve_executor(
            server_name,
            remote_name,
            access_key=access_key,
            project_id=project_id,
            user_id=user_id,
        )
        out['storage'] = get_bohrium_storage_config(
            access_key=access_key,
            project_id=project_id,
            user_id=user_id,
        )

        # --- Path resolution: schema-driven only ---
        path_arg_names = _path_keys_from_schema(input_schema)
        if path_arg_names:
            logger.debug(
                "Tool %s: detected Path-typed params from schema: %s",
                remote_name,
                sorted(path_arg_names),
            )
        if not path_arg_names or not workspace_path:
            return out

        workspace_root = Path(workspace_path).resolve()
        for key in sorted(path_arg_names):
            if key not in out:
                continue
            val = out[key]
            if isinstance(val, list):
                out[key] = [_resolve_one(str(v), workspace_root) for v in val]
            else:
                out[key] = _resolve_one(str(val), workspace_root)
        return out


def get_calculation_path_adaptor(
    mcp_config: Optional[Dict[str, Any]] = None,
) -> CalculationPathAdaptor:
    """Return a calculation path adaptor. If mcp_config has calculation_executors, use it for executor/sync_tools."""
    executors = (
        (mcp_config or {}).get('calculation_executors')
        if mcp_config is not None
        else None
    )
    return CalculationPathAdaptor(calculation_executors=executors)
